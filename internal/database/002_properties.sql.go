// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: 002_properties.sql

package database

import (
	"context"
	"database/sql"
	"encoding/json"
)

const createProperty = `-- name: CreateProperty :execresult
INSERT INTO properties (id, owner_id, name, description, location, price, amenities)
VALUES (?, ?, ?, ?, ?, ?, ?)
`

type CreatePropertyParams struct {
	ID          string          `json:"id"`
	OwnerID     string          `json:"owner_id"`
	Name        string          `json:"name"`
	Description sql.NullString  `json:"description"`
	Location    string          `json:"location"`
	Price       string          `json:"price"`
	Amenities   json.RawMessage `json:"amenities"`
}

func (q *Queries) CreateProperty(ctx context.Context, arg CreatePropertyParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createProperty,
		arg.ID,
		arg.OwnerID,
		arg.Name,
		arg.Description,
		arg.Location,
		arg.Price,
		arg.Amenities,
	)
}

const getPropertyByID = `-- name: GetPropertyByID :one
SELECT 
  properties.id AS property_id,
  properties.owner_id,
  properties.name,
  properties.description,
  properties.location,
  properties.price,
  properties.amenities,
  properties.created_at,
  COALESCE(
    JSON_ARRAYAGG(
      JSON_OBJECT('id', v.id, 'name', v.name, 'price', v.price, 'max_guests', v.max_guests, 'is_available', v.is_available)),
    '[]') AS rooms
FROM properties LEFT JOIN rooms v ON properties.id = rooms.property_id
WHERE properties.id = ? AND properties.deleted_at IS NULL
`

type GetPropertyByIDRow struct {
	PropertyID  string          `json:"property_id"`
	OwnerID     string          `json:"owner_id"`
	Name        string          `json:"name"`
	Description sql.NullString  `json:"description"`
	Location    string          `json:"location"`
	Price       string          `json:"price"`
	Amenities   json.RawMessage `json:"amenities"`
	CreatedAt   sql.NullTime    `json:"created_at"`
	Rooms       interface{}     `json:"rooms"`
}

func (q *Queries) GetPropertyByID(ctx context.Context, id string) (GetPropertyByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getPropertyByID, id)
	var i GetPropertyByIDRow
	err := row.Scan(
		&i.PropertyID,
		&i.OwnerID,
		&i.Name,
		&i.Description,
		&i.Location,
		&i.Price,
		&i.Amenities,
		&i.CreatedAt,
		&i.Rooms,
	)
	return i, err
}

const listPropertiesByOwner = `-- name: ListPropertiesByOwner :many
SELECT 
  properties.id AS property_id,
  properties.owner_id,
  properties.name,
  properties.description,
  properties.location,
  properties.price,
  properties.amenities,
  properties.created_at
FROM properties
WHERE properties.owner_id = ? AND properties.deleted_at IS NULL
ORDER BY properties.created_at DESC
LIMIT ? OFFSET ?
`

type ListPropertiesByOwnerParams struct {
	OwnerID string `json:"owner_id"`
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
}

type ListPropertiesByOwnerRow struct {
	PropertyID  string          `json:"property_id"`
	OwnerID     string          `json:"owner_id"`
	Name        string          `json:"name"`
	Description sql.NullString  `json:"description"`
	Location    string          `json:"location"`
	Price       string          `json:"price"`
	Amenities   json.RawMessage `json:"amenities"`
	CreatedAt   sql.NullTime    `json:"created_at"`
}

func (q *Queries) ListPropertiesByOwner(ctx context.Context, arg ListPropertiesByOwnerParams) ([]ListPropertiesByOwnerRow, error) {
	rows, err := q.db.QueryContext(ctx, listPropertiesByOwner, arg.OwnerID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListPropertiesByOwnerRow
	for rows.Next() {
		var i ListPropertiesByOwnerRow
		if err := rows.Scan(
			&i.PropertyID,
			&i.OwnerID,
			&i.Name,
			&i.Description,
			&i.Location,
			&i.Price,
			&i.Amenities,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchProperties = `-- name: SearchProperties :many
SELECT 
  properties.id AS property_id,
  properties.owner_id,
  properties.name,
  properties.description,
  properties.location,
  properties.price,
  properties.amenities,
  properties.created_at
FROM properties
WHERE properties.deleted_at IS NULL
  AND MATCH(properties.name, properties.location) AGAINST (? IN NATURAL LANGUAGE MODE)
  AND properties.price BETWEEN ? AND ?
ORDER BY properties.price ASC, properties.created_at DESC
LIMIT ? OFFSET ?
`

type SearchPropertiesParams struct {
	FromPrice string `json:"from_price"`
	ToPrice   string `json:"to_price"`
	Limit     int32  `json:"limit"`
	Offset    int32  `json:"offset"`
}

type SearchPropertiesRow struct {
	PropertyID  string          `json:"property_id"`
	OwnerID     string          `json:"owner_id"`
	Name        string          `json:"name"`
	Description sql.NullString  `json:"description"`
	Location    string          `json:"location"`
	Price       string          `json:"price"`
	Amenities   json.RawMessage `json:"amenities"`
	CreatedAt   sql.NullTime    `json:"created_at"`
}

func (q *Queries) SearchProperties(ctx context.Context, arg SearchPropertiesParams) ([]SearchPropertiesRow, error) {
	rows, err := q.db.QueryContext(ctx, searchProperties,
		arg.FromPrice,
		arg.ToPrice,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchPropertiesRow
	for rows.Next() {
		var i SearchPropertiesRow
		if err := rows.Scan(
			&i.PropertyID,
			&i.OwnerID,
			&i.Name,
			&i.Description,
			&i.Location,
			&i.Price,
			&i.Amenities,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const softDeleteProperty = `-- name: SoftDeleteProperty :exec
UPDATE properties SET deleted_at = NOW() WHERE id = ?
`

func (q *Queries) SoftDeleteProperty(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, softDeleteProperty, id)
	return err
}

const updateProperty = `-- name: UpdateProperty :exec
UPDATE properties
SET name = COALESCE(?, name), description = COALESCE(?, description), location = COALESCE(?, location), price = COALESCE(?, price), amenities = COALESCE(?, amenities)
WHERE id = ? AND deleted_at IS NULL
`

type UpdatePropertyParams struct {
	Name        string          `json:"name"`
	Description sql.NullString  `json:"description"`
	Location    string          `json:"location"`
	Price       string          `json:"price"`
	Amenities   json.RawMessage `json:"amenities"`
	ID          string          `json:"id"`
}

func (q *Queries) UpdateProperty(ctx context.Context, arg UpdatePropertyParams) error {
	_, err := q.db.ExecContext(ctx, updateProperty,
		arg.Name,
		arg.Description,
		arg.Location,
		arg.Price,
		arg.Amenities,
		arg.ID,
	)
	return err
}
