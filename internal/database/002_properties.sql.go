// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: 002_properties.sql

package database

import (
	"context"
	"database/sql"
	"encoding/json"
)

const createProperty = `-- name: CreateProperty :execresult
INSERT INTO properties (id, owner_id, name, description, location, price, amenities)
VALUES (?, ?, ?, ?, ?, ?, ?)
`

type CreatePropertyParams struct {
	ID          string
	OwnerID     string
	Name        string
	Description sql.NullString
	Location    string
	Price       string
	Amenities   json.RawMessage
}

func (q *Queries) CreateProperty(ctx context.Context, arg CreatePropertyParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createProperty,
		arg.ID,
		arg.OwnerID,
		arg.Name,
		arg.Description,
		arg.Location,
		arg.Price,
		arg.Amenities,
	)
}

const getPropertyByID = `-- name: GetPropertyByID :one
SELECT 
  properties.id AS property_id,
  properties.owner_id,
  properties.name,
  properties.description,
  properties.location,
  properties.price,
  properties.amenities,
  properties.created_at
FROM properties
WHERE properties.id = ? AND properties.deleted_at IS NULL
`

type GetPropertyByIDRow struct {
	PropertyID  string
	OwnerID     string
	Name        string
	Description sql.NullString
	Location    string
	Price       string
	Amenities   json.RawMessage
	CreatedAt   sql.NullTime
}

func (q *Queries) GetPropertyByID(ctx context.Context, id string) (GetPropertyByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getPropertyByID, id)
	var i GetPropertyByIDRow
	err := row.Scan(
		&i.PropertyID,
		&i.OwnerID,
		&i.Name,
		&i.Description,
		&i.Location,
		&i.Price,
		&i.Amenities,
		&i.CreatedAt,
	)
	return i, err
}

const listPropertiesByOwner = `-- name: ListPropertiesByOwner :many
SELECT 
  properties.id AS property_id,
  properties.owner_id,
  properties.name,
  properties.description,
  properties.location,
  properties.price,
  properties.amenities,
  properties.created_at
FROM properties
WHERE properties.owner_id = ? AND properties.deleted_at IS NULL
ORDER BY properties.created_at DESC
LIMIT ? OFFSET ?
`

type ListPropertiesByOwnerParams struct {
	OwnerID string
	Limit   int32
	Offset  int32
}

type ListPropertiesByOwnerRow struct {
	PropertyID  string
	OwnerID     string
	Name        string
	Description sql.NullString
	Location    string
	Price       string
	Amenities   json.RawMessage
	CreatedAt   sql.NullTime
}

func (q *Queries) ListPropertiesByOwner(ctx context.Context, arg ListPropertiesByOwnerParams) ([]ListPropertiesByOwnerRow, error) {
	rows, err := q.db.QueryContext(ctx, listPropertiesByOwner, arg.OwnerID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListPropertiesByOwnerRow
	for rows.Next() {
		var i ListPropertiesByOwnerRow
		if err := rows.Scan(
			&i.PropertyID,
			&i.OwnerID,
			&i.Name,
			&i.Description,
			&i.Location,
			&i.Price,
			&i.Amenities,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchProperties = `-- name: SearchProperties :many
SELECT 
  properties.id AS property_id,
  properties.owner_id,
  properties.name,
  properties.description,
  properties.location,
  properties.price,
  properties.amenities,
  properties.created_at
FROM properties
WHERE properties.deleted_at IS NULL
  AND MATCH(properties.name, properties.location) AGAINST (? IN NATURAL LANGUAGE MODE)
  AND properties.price BETWEEN ? AND ?
ORDER BY properties.price ASC, properties.created_at DESC
LIMIT ? OFFSET ?
`

type SearchPropertiesParams struct {
	FromPrice string
	ToPrice   string
	Limit     int32
	Offset    int32
}

type SearchPropertiesRow struct {
	PropertyID  string
	OwnerID     string
	Name        string
	Description sql.NullString
	Location    string
	Price       string
	Amenities   json.RawMessage
	CreatedAt   sql.NullTime
}

func (q *Queries) SearchProperties(ctx context.Context, arg SearchPropertiesParams) ([]SearchPropertiesRow, error) {
	rows, err := q.db.QueryContext(ctx, searchProperties,
		arg.FromPrice,
		arg.ToPrice,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchPropertiesRow
	for rows.Next() {
		var i SearchPropertiesRow
		if err := rows.Scan(
			&i.PropertyID,
			&i.OwnerID,
			&i.Name,
			&i.Description,
			&i.Location,
			&i.Price,
			&i.Amenities,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const softDeleteProperty = `-- name: SoftDeleteProperty :exec
UPDATE properties SET deleted_at = NOW() WHERE id = ?
`

func (q *Queries) SoftDeleteProperty(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, softDeleteProperty, id)
	return err
}

const updateProperty = `-- name: UpdateProperty :exec
UPDATE properties
SET name = ?, description = ?, location = ?, price = ?, amenities = ?
WHERE id = ? AND deleted_at IS NULL
`

type UpdatePropertyParams struct {
	Name        string
	Description sql.NullString
	Location    string
	Price       string
	Amenities   json.RawMessage
	ID          string
}

func (q *Queries) UpdateProperty(ctx context.Context, arg UpdatePropertyParams) error {
	_, err := q.db.ExecContext(ctx, updateProperty,
		arg.Name,
		arg.Description,
		arg.Location,
		arg.Price,
		arg.Amenities,
		arg.ID,
	)
	return err
}
