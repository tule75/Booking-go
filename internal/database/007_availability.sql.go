// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: 007_availability.sql

package database

import (
	"context"
	"database/sql"
	"time"
)

const createAvailability = `-- name: CreateAvailability :execresult
INSERT INTO ` + "`" + `availability` + "`" + ` (id, room_id, date, is_available)
VALUES (?, ?, ?, ?)
`

type CreateAvailabilityParams struct {
	ID          string       `json:"id"`
	RoomID      string       `json:"room_id"`
	Date        time.Time    `json:"date"`
	IsAvailable sql.NullBool `json:"is_available"`
}

func (q *Queries) CreateAvailability(ctx context.Context, arg CreateAvailabilityParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createAvailability,
		arg.ID,
		arg.RoomID,
		arg.Date,
		arg.IsAvailable,
	)
}

const getAvailabilityByID = `-- name: GetAvailabilityByID :one
SELECT 
  availability.id AS availability_id,
  availability.room_id,
  availability.date,
  availability.is_available
FROM ` + "`" + `availability` + "`" + `
WHERE availability.id = ? AND availability.deleted_at IS NULL
`

type GetAvailabilityByIDRow struct {
	AvailabilityID string       `json:"availability_id"`
	RoomID         string       `json:"room_id"`
	Date           time.Time    `json:"date"`
	IsAvailable    sql.NullBool `json:"is_available"`
}

func (q *Queries) GetAvailabilityByID(ctx context.Context, id string) (GetAvailabilityByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getAvailabilityByID, id)
	var i GetAvailabilityByIDRow
	err := row.Scan(
		&i.AvailabilityID,
		&i.RoomID,
		&i.Date,
		&i.IsAvailable,
	)
	return i, err
}

const listAvailabilityByRoomAndDateRange = `-- name: ListAvailabilityByRoomAndDateRange :many
SELECT 
  availability.id AS availability_id,
  availability.room_id,
  availability.date,
  availability.is_available
FROM availability
WHERE availability.room_id = ?
  AND availability.deleted_at IS NULL
  AND availability.date BETWEEN ? AND ?
ORDER BY availability.date ASC
`

type ListAvailabilityByRoomAndDateRangeParams struct {
	RoomID   string    `json:"room_id"`
	FromDate time.Time `json:"from_date"`
	ToDate   time.Time `json:"to_date"`
}

type ListAvailabilityByRoomAndDateRangeRow struct {
	AvailabilityID string       `json:"availability_id"`
	RoomID         string       `json:"room_id"`
	Date           time.Time    `json:"date"`
	IsAvailable    sql.NullBool `json:"is_available"`
}

func (q *Queries) ListAvailabilityByRoomAndDateRange(ctx context.Context, arg ListAvailabilityByRoomAndDateRangeParams) ([]ListAvailabilityByRoomAndDateRangeRow, error) {
	rows, err := q.db.QueryContext(ctx, listAvailabilityByRoomAndDateRange, arg.RoomID, arg.FromDate, arg.ToDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAvailabilityByRoomAndDateRangeRow
	for rows.Next() {
		var i ListAvailabilityByRoomAndDateRangeRow
		if err := rows.Scan(
			&i.AvailabilityID,
			&i.RoomID,
			&i.Date,
			&i.IsAvailable,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAvailability = `-- name: UpdateAvailability :exec
UPDATE availability
SET is_available = ?
WHERE id = ? AND deleted_at IS NULL
`

type UpdateAvailabilityParams struct {
	IsAvailable sql.NullBool `json:"is_available"`
	ID          string       `json:"id"`
}

func (q *Queries) UpdateAvailability(ctx context.Context, arg UpdateAvailabilityParams) error {
	_, err := q.db.ExecContext(ctx, updateAvailability, arg.IsAvailable, arg.ID)
	return err
}
