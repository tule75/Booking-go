// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: 008_notifications.sql

package database

import (
	"context"
	"database/sql"
)

const createNotification = `-- name: CreateNotification :execresult
INSERT INTO notifications (id, user_id, message, is_read)
VALUES (?, ?, ?, ?)
`

type CreateNotificationParams struct {
	ID      string       `json:"id"`
	UserID  string       `json:"user_id"`
	Message string       `json:"message"`
	IsRead  sql.NullBool `json:"is_read"`
}

func (q *Queries) CreateNotification(ctx context.Context, arg CreateNotificationParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createNotification,
		arg.ID,
		arg.UserID,
		arg.Message,
		arg.IsRead,
	)
}

const getNotificationByID = `-- name: GetNotificationByID :one
SELECT 
  notifications.id AS notification_id,
  notifications.user_id,
  notifications.message,
  notifications.is_read,
  notifications.created_at
FROM notifications
WHERE notifications.id = ? AND notifications.deleted_at IS NULL
`

type GetNotificationByIDRow struct {
	NotificationID string       `json:"notification_id"`
	UserID         string       `json:"user_id"`
	Message        string       `json:"message"`
	IsRead         sql.NullBool `json:"is_read"`
	CreatedAt      sql.NullTime `json:"created_at"`
}

func (q *Queries) GetNotificationByID(ctx context.Context, id string) (GetNotificationByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getNotificationByID, id)
	var i GetNotificationByIDRow
	err := row.Scan(
		&i.NotificationID,
		&i.UserID,
		&i.Message,
		&i.IsRead,
		&i.CreatedAt,
	)
	return i, err
}

const listNotificationsByUser = `-- name: ListNotificationsByUser :many
SELECT 
  notifications.id AS notification_id,
  notifications.user_id,
  notifications.message,
  notifications.is_read,
  notifications.created_at
FROM notifications
WHERE notifications.user_id = ?
  AND notifications.deleted_at IS NULL
  AND ( ? IS NULL OR notifications.is_read = ? )
ORDER BY notifications.created_at DESC
LIMIT ? OFFSET ?
`

type ListNotificationsByUserParams struct {
	UserID  string       `json:"user_id"`
	Column2 interface{}  `json:"column_2"`
	IsRead  sql.NullBool `json:"is_read"`
	Limit   int32        `json:"limit"`
	Offset  int32        `json:"offset"`
}

type ListNotificationsByUserRow struct {
	NotificationID string       `json:"notification_id"`
	UserID         string       `json:"user_id"`
	Message        string       `json:"message"`
	IsRead         sql.NullBool `json:"is_read"`
	CreatedAt      sql.NullTime `json:"created_at"`
}

func (q *Queries) ListNotificationsByUser(ctx context.Context, arg ListNotificationsByUserParams) ([]ListNotificationsByUserRow, error) {
	rows, err := q.db.QueryContext(ctx, listNotificationsByUser,
		arg.UserID,
		arg.Column2,
		arg.IsRead,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListNotificationsByUserRow
	for rows.Next() {
		var i ListNotificationsByUserRow
		if err := rows.Scan(
			&i.NotificationID,
			&i.UserID,
			&i.Message,
			&i.IsRead,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markNotificationAsRead = `-- name: MarkNotificationAsRead :exec
UPDATE notifications
SET is_read = TRUE
WHERE id = ? AND deleted_at IS NULL
`

func (q *Queries) MarkNotificationAsRead(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, markNotificationAsRead, id)
	return err
}
